/*Generated by WaveMaker Studio*/
package com.rb_transactions_only_prefab.fundcardoraccount;

import java.io.IOException;
import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

import javax.servlet.http.HttpServletRequest;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.util.LinkedMultiValueMap;
import org.springframework.util.MultiValueMap;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.jayway.jsonpath.JsonPath;
import com.transfer_funds.BNKTransfer.model.CardLoadBody;
import com.transfer_funds.BNKTransfer.model.CardholderInfoBody;
import com.transfer_funds.BNKTransfer.model.ConsumerAccountlistBody;
import com.transfer_funds.BNKTransfer.model.InlineResponse200;
import com.transfer_funds.BNKTransfer.model.InlineResponse20060;
import com.transfer_funds.BNKTransfer.model.VirtualaccountBalanceBody;
import com.transfer_funds.BNKTransfer.service.CardManagementService;
import com.transfer_funds.BNKTransfer.service.CardsPrepaidComingToYourSandboxSoonService;
import com.transfer_funds.BNKTransfer.service.ConsumerService;
import com.transfer_funds.BNKTransfer.service.VirtualAccountsService;
import com.transfer_funds.RBSwagger.model.CustomerTransactionsBody;
import com.transfer_funds.RBSwagger.service.CustomerService;
import com.transfer_funds.bnktransferservice.BnkTransferService;
import com.transfer_funds.wvrTransfer.model.InlineResponse20013;
import com.transfer_funds.wvrTransfer.model.InlineResponse2002;
import com.transfer_funds.wvrTransfer.model.TransfersBody;
import com.transfer_funds.wvrTransfer.service.ManagedAccountsService;
import com.transfer_funds.wvrTransfer.service.ManagedCardsService;
import com.transfer_funds.wvrTransfer.service.TransfersService;
import com.transfer_funds.wvrtransferservice.WvrTransferService;
import com.wavemaker.runtime.rest.RequestContext;
import com.wavemaker.runtime.rest.RestExecutor;
import com.wavemaker.runtime.service.annotations.ExposeToClient;
//import com.rb_transactions_only_prefab.fundcardoraccount.model.*;

/**
 * This is a singleton class with all its public methods exposed as REST APIs via generated controller class. To avoid exposing an API for a particular public
 * method, annotate it with @HideFromClient.
 * <p>
 * Method names will play a major role in defining the Http Method for the generated APIs. For example, a method name that starts with delete/remove, will make
 * the API exposed as Http Method "DELETE".
 * <p>
 * Method Parameters of type primitives (including java.lang.String) will be exposed as Query Parameters & Complex Types/Objects will become part of the Request
 * body in the generated API.
 * <p>
 * NOTE: We do not recommend using method overloading on client exposed methods.
 */
@ExposeToClient
public class FundCardOrAccount {

    private static final Logger logger = LoggerFactory.getLogger(FundCardOrAccount.class);

    private static final ObjectMapper objectMapper = new ObjectMapper();
    WvrTransferService wvrTransferService = new WvrTransferService();
    BnkTransferService bnkTransferService = new BnkTransferService();
    private static final String API_KEY = "api-key";
    private static final String APIVENDOR_R = "APIVendor(R)";
    private static final String APIVENDOR_W = "APIVendor(W)";
    private static final String APIVENDOR_B = "APIVendor(B)";

    @Autowired
    private TransfersService wTransferService;

    @Autowired
    private ManagedCardsService wCardsService;

    @Autowired
    private ManagedAccountsService wAccountsService;

    @Autowired
    private CustomerService rTransferService;

    @Autowired
    private CardsPrepaidComingToYourSandboxSoonService bTransferService;

    @Autowired
    private CardManagementService bCardsService;

    @Autowired
    private ConsumerService bConsumerService;

    @Autowired
    private VirtualAccountsService bAccountsService;

    @Autowired
    private RestExecutor restExecutor;

    @Value("${apikey}")
    private String apiKey;

    @Value("${transfersprofileid}")
    private String transferProfileId;

    public Object fundManagedCards(String hostName, String authorization, Map<String, Object> formData,
                                   HttpServletRequest servletRequest) throws IOException {
        if (hostName.contains(APIVENDOR_W)) {
            TransfersBody request = wvrTransferService.wvFundCardRequest(formData, transferProfileId);
            RequestContext context = RequestContext.Builder.newInstance().addHeader(API_KEY, apiKey).addJwtToken(authorization).build();
            return restExecutor.executeWithContext(context, () -> {
                return wTransferService.transferCreate(request, "");
            });
        } else if (hostName.contains(APIVENDOR_R)) {
            CustomerTransactionsBody request = fundCardRequest(formData);
            return rTransferService.pOSTV1CustomerTransactions(request);
        } else if (hostName.contains(APIVENDOR_B)) {
            CardLoadBody request = bnkTransferService.bankableFundCardRequest(formData, transferProfileId);
            return bTransferService.postCardLoad(request, apiKey);
        }
        return null;
    }

    public List getAllManagedCardsOrBeneficiaries(String hostName, String authorization, String profileOrUserId,
                                                  HttpServletRequest servletRequest) throws IOException {
        if (hostName.contains(APIVENDOR_W)) {
            RequestContext context = RequestContext.Builder.newInstance().addHeader(API_KEY, apiKey).addJwtToken(authorization).build();
            return restExecutor.executeWithContext(context, () -> {
                InlineResponse2002 response = wCardsService.managedCardsGet("", new LinkedMultiValueMap<>());
                return response.getCards();
            });
        } else if (hostName.contains(APIVENDOR_R)) {
            MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<>();
            queryParams.add("holder_id", profileOrUserId);
            queryParams.add("items_per_page", "100");
            queryParams.add("offset", "0");
            return rTransferService.gETV1CustomerBeneficiaries(queryParams);
        } else if (hostName.contains(APIVENDOR_B)) {
            CardholderInfoBody card = bnkTransferService.constructAllCardsDetail(transferProfileId, profileOrUserId);
            InlineResponse200 response = bCardsService.postCardHolderInfo(card, apiKey);
            return response.getCardInfos();
        }
        return new ArrayList<>();
    }

    public List getAllManagedAccountsOrLedgers(String hostName, String authorization, String profileOrUserId,
                                               HttpServletRequest servletRequest) throws IOException {
        if (hostName.contains(APIVENDOR_W)) {
            RequestContext context = RequestContext.Builder.newInstance().addHeader(API_KEY, apiKey).addJwtToken(authorization).build();
            return restExecutor.executeWithContext(context, () -> {
                InlineResponse20013 response = wAccountsService.managedAccountsGet("", new LinkedMultiValueMap<>());
                return response.getAccounts();
            });
        } else if (hostName.contains(APIVENDOR_R)) {
            MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<>();
            queryParams.add("holder_id", profileOrUserId);
            queryParams.add("items_per_page", "40");
            queryParams.add("offset", "0");
            return rTransferService.gETV1CustomerLedgers(queryParams);
        } else if (hostName.contains(APIVENDOR_B)) {
            ConsumerAccountlistBody request = bnkTransferService.constructAllAccountDetails(transferProfileId, profileOrUserId);
            InlineResponse20060 response = bConsumerService.postConsumerAccountList(request, apiKey);
            return response.getVirtualAccountList();
        }
        return new ArrayList<>();
    }

    public Object getManagedAccountDetailsById(String hostName, String authorization, String managedAccountId,
                                               HttpServletRequest servletRequest) throws IOException {
        if (hostName.contains(APIVENDOR_R)) {
            return rTransferService.gETV1CustomerLedgersLedgerIdEntries(managedAccountId, new LinkedMultiValueMap<>());
        } else if (hostName.contains(APIVENDOR_W)) {
            RequestContext context = RequestContext.Builder.newInstance().addHeader(API_KEY, apiKey).addJwtToken(authorization).build();
            return restExecutor.executeWithContext(context, () -> {
                return wAccountsService.managedAccountGet(managedAccountId, "");
            });
        } else if (hostName.contains(APIVENDOR_B)) {
            VirtualaccountBalanceBody account = bnkTransferService.getAccountDetailsById(transferProfileId, managedAccountId);
            return bAccountsService.postVirtualAccountBalance(account, apiKey);
        }
        return null;
    }

    private CustomerTransactionsBody fundCardRequest(Map<String, Object> formData) throws IOException {
        Map<String, Object> fundInfo = JsonPath.parse(objectMapper.writeValueAsString(formData)).read("$");
        CustomerTransactionsBody request = new CustomerTransactionsBody();
        request.setLedgerId(formData.get("ledger_id").toString());
        request.setBeneficiaryId(formData.get("beneficiary_id").toString());
        request.setAmount(BigDecimal.valueOf(Double.parseDouble(formData.get("amount").toString())));
        request.setPaymentType(CustomerTransactionsBody.PaymentTypeEnum.valueOf(formData.get("payment_type").toString()));
        request.setPaymentCreditDate(LocalDate.parse(formData.get("payment_credit_date").toString()));
        request.setTransactionMeta(new LinkedHashMap<String, String>() {{
            put("Notes", fundInfo.get("Notes").toString());
            put("assetType", fundInfo.get("assetType").toString());
        }});
        return request;
    }


}
